---
title: "MT5767 Project 1"
author: "Lachlan MacLean, Misha Tseitlin, Liam Gerrity"
date: "23/10/2023"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load and set, include = FALSE}

# Load relevant libraries
library(tidyverse)
library(remotes)
remotes::install_github("chrissuthy/statsecol")
library(statsecol)
str(wildebeest)
library(gridExtra)
library(knitr)

# Set seed for reproducibility
set.seed(576711)

```

# Contribution Statement

This report is the joint product of all of the above mentioned members with each member producing the code, analysis and write up for separate questions. Question 1 was completed by LM, Question 2 by MT and Question 3 by LG.

------------------------------------------------------------------------

# Question 1

```{r Q1 code, include = FALSE}

# a)

# See written report

# b)

# Write an R script to simulate dynamics from this model.
# we do this in a function.

# INPUT : 
# n0 = initial populations
# phi = survival probabilities
# rho = reproduction rates
# p = probability of detection
# nyears = number of years over which population is projected
# PROCESS : 
# calculate the stochastic population dynamics and observations for each year
# OUTPUT :
# y = array of observations for each year, across all age classes
# n = array of abundances for each year, across all age classes

BAS_stoch <- function(n0, phi, rho, p, nyears) {
  
  # initialise
  
  # matrix of all abundances, each column is a year, row is age class
  n <- matrix(data = NA, nrow = length(n0), ncol = (nyears+1))
  
  # matrix of all observations
  y <- n #replicate n
  
  # initial abundance
  # let the first set of abundances (at t = 0) be the initial population size
  n[,1] <- n0
  
  # initial observation
  # ASSUMPTION: binomial distribution as constant probability of detection (see Newman)
  y[1,1] <- rbinom(n = 1, size = n[1,1], prob = p)
  y[2,1] <- rbinom(n = 1, size = n[2,1], prob = p)
  y[3,1] <- rbinom(n = 1, size = n[3,1], prob = p)
  y[4,1] <- rbinom(n = 1, size = n[4,1], prob = p)
  
  # loop over all (other) years
  for (i in 2:(nyears+1)) {
    
    # calculate stochastic sub-processes for BAS model
    
    # Survival process
    u_1s1t <- rbinom(n = 1, size = n[1,i-1], prob = phi[1])
    u_1s2t <- rbinom(n = 1, size = n[2,i-1], prob = phi[2])
    u_1s3t <- rbinom(n = 1, size = n[3,i-1], prob = phi[3])
    u_1s4t <- 0
    
    # Ageing process
    u_2a1t <- 0
    u_2a2t <- u_1s1t
    u_2a3t <- u_1s2t
    u_2a4t <- u_1s3t + u_1s4t
    
    # Reproduction/Birth process
    u_3b1t <- rpois(n = 1, lambda = rho[1] * u_2a2t) + 
              rpois(n = 1, lambda = rho[2] * u_2a3t)
    u_3b2t <- u_2a2t
    u_3b3t <- u_2a3t
    u_3b4t <- u_2a4t
    
    # new abundances
    n[,i] <- c(u_3b1t, u_3b2t, u_3b3t, u_3b4t)
    
    # new observations
    y[1,i] <- rbinom(n = 1, size = n[1,i], prob = p)
    y[2,i] <- rbinom(n = 1, size = n[2,i], prob = p)
    y[3,i] <- rbinom(n = 1, size = n[3,i], prob = p)
    y[4,i] <- rbinom(n = 1, size = n[4,i], prob = p)
  }
  
  # return
  return(list(n=n,y=y))
  
}

# parameters from specification
phi <- c(0.45, 0.7, 0.7)
rho <- c(0.9, 1.9)
p <- 0.5
n0 <- c(150, 70, 50, 30)

# c)

# Simulate 25 years of age-specific population dynamics and observations and 
# produce an informative visualisation of the data.

# specify how many years to project over
nyears <- 25

# run function for 25 years
BAS_proj <- BAS_stoch(n0 = n0, phi = phi, rho = rho, p = p, nyears = nyears)

# visualise the data using a faceted ggplot.

# convert both outputs to dataframes
proj_n_df <- as.data.frame( cbind(0:nyears, t(BAS_proj$n), 
                    rep(2,(nyears+1))) )
proj_y_df <- as.data.frame( cbind(0:nyears, t(BAS_proj$y), 
                    rep(1,(nyears+1))) )

# rename
colnames(proj_n_df) <- c("Year", "First Year Individuals", 
                         "Second Year Individuals", 
                         "Third Year Individuals", 
                         "Fourth Year Individuals", "State")
colnames(proj_y_df) <- c("Year", "First Year Individuals", 
                         "Second Year Individuals", 
                         "Third Year Individuals", 
                         "Fourth Year Individuals", "State")

# pivot longer
proj_n_df_long <- pivot_longer(data = proj_n_df, 
                               cols = c("First Year Individuals", 
                                        "Second Year Individuals", 
                                        "Third Year Individuals", 
                                        "Fourth Year Individuals"))
proj_y_df_long <- pivot_longer(data = proj_y_df, 
                               cols = c("First Year Individuals", 
                                        "Second Year Individuals", 
                                        "Third Year Individuals", 
                                        "Fourth Year Individuals"))
proj_df_long <- rbind(proj_n_df_long, proj_y_df_long)
colnames(proj_df_long) <- c("Year", "State", "Age Class", "Abundance")

# change variable types
proj_df_long$State <- as.factor(proj_df_long$State)
proj_df_long$`Age Class` <- as.factor(proj_df_long$`Age Class`)

# Can now easily use faceted ggplot
plot_BAS <- ggplot(data = proj_df_long, aes(x = Year, y = Abundance)) + 
  geom_line(aes(colour = State), size = 1) +
  scale_colour_manual("State", breaks = c(2, 1),
                      values = c("blue", "grey"), 
                      labels = c("Dynamics","Observations")) +
  facet_wrap(~factor(`Age Class`, levels = c("First Year Individuals", 
                                             "Second Year Individuals", 
                                             "Third Year Individuals", 
                                             "Fourth Year Individuals")), 
             scales = "free_y") +
  ylab("Abundance") +
  ggtitle("Population Dynamics and Observations Projected over Time")
plot_BAS

# Extension to part b) and c)

# Create a new function like in b), but runs poisson instead of Binomial for 
# observations

# INPUT : 
# n0 = initial populations
# phi = survival probabilities
# rho = reproduction rates
# p = probability of detection
# nyears = number of years over which population is projected
# PROCESS : 
# calculate the stochastic population dynamics and observations for each year
# OUTPUT :
# y = array of observations for each year, across all age classes
# n = array of abundances for each year, across all age classes

BAS_extension <- function(n0, phi, rho, p, nyears) {
  
  # initialise
  
  # matrix of all abundances, each column is a year, row is age class
  n <- matrix(data = NA, nrow = length(n0), ncol = (nyears+1))
  
  # matrix of all observations
  y <- n #replicate n
  
  # initial abundance
  # let the first set of abundances (at t = 0) be the initial population size
  n[,1] <- n0
  
  # initial observation
  y[1,1] <- rpois(n = 1, lambda = n[1,1]*p)
  y[2,1] <- rpois(n = 1, lambda = n[2,1]*p)
  y[3,1] <- rpois(n = 1, lambda = n[3,1]*p)
  y[4,1] <- rpois(n = 1, lambda = n[4,1]*p)
  
  # loop over all (other) years
  for (i in 2:(nyears+1)) {
    
    # calculate stochastic sub-processes for BAS model
    
    # Survival process
    u_1s1t <- rbinom(n = 1, size = n[1,i-1], prob = phi[1])
    u_1s2t <- rbinom(n = 1, size = n[2,i-1], prob = phi[2])
    u_1s3t <- rbinom(n = 1, size = n[3,i-1], prob = phi[3])
    u_1s4t <- 0
    
    # Ageing process
    u_2a1t <- 0
    u_2a2t <- u_1s1t
    u_2a3t <- u_1s2t
    u_2a4t <- u_1s3t + u_1s4t
    
    # Reproduction/Birth process
    u_3b1t <- rpois(n = 1, lambda = rho[1] * u_2a2t) + 
      rpois(n = 1, lambda = rho[2] * u_2a3t)
    u_3b2t <- u_2a2t
    u_3b3t <- u_2a3t
    u_3b4t <- u_2a4t
    
    # new abundances
    n[,i] <- c(u_3b1t, u_3b2t, u_3b3t, u_3b4t)
    
    # new observations
    y[1,i] <- rpois(n = 1, lambda = n[1,i]*p)
    y[2,i] <- rpois(n = 1, lambda = n[2,i]*p)
    y[3,i] <- rpois(n = 1, lambda = n[3,i]*p)
    y[4,i] <- rpois(n = 1, lambda = n[4,i]*p)
  }
  
  # return
  return(list(n=n,y=y))
  
}

# Simulate 25 years of age-specific population dynamics and observations and 
# produce an informative visualisation of the data.

# run function for 25 years
# use same parameter values as above
BAS_proj_ext <- BAS_extension(n0 = n0, phi = phi, rho = rho, p = p, 
                              nyears = nyears)

# visualise the data using a faceted ggplot.

# convert both outputs to dataframes
proj_n_df <- as.data.frame( cbind(0:nyears, t(BAS_proj_ext$n), 
                                  rep(2,(nyears+1))) )
proj_y_df <- as.data.frame( cbind(0:nyears, t(BAS_proj_ext$y), 
                                  rep(1,(nyears+1))) )

# rename
colnames(proj_n_df) <- c("Year", "First Year Individuals", 
                         "Second Year Individuals", 
                         "Third Year Individuals", 
                         "Fourth Year Individuals", "State")
colnames(proj_y_df) <- c("Year", "First Year Individuals", 
                         "Second Year Individuals", 
                         "Third Year Individuals", 
                         "Fourth Year Individuals", "State")

# pivot longer
proj_n_df_long <- pivot_longer(data = proj_n_df, 
                               cols = c("First Year Individuals", 
                                        "Second Year Individuals", 
                                        "Third Year Individuals", 
                                        "Fourth Year Individuals"))
proj_y_df_long <- pivot_longer(data = proj_y_df, 
                               cols = c("First Year Individuals", 
                                        "Second Year Individuals", 
                                        "Third Year Individuals", 
                                        "Fourth Year Individuals"))
proj_df_long <- rbind(proj_n_df_long, proj_y_df_long)
colnames(proj_df_long) <- c("Year", "State", "Age Class", "Abundance")

# change variable types
proj_df_long$State <- as.factor(proj_df_long$State)
proj_df_long$`Age Class` <- as.factor(proj_df_long$`Age Class`)

# Can now easily use faceted ggplot
plot_BAS_ext <- ggplot(data = proj_df_long, aes(x = Year, y = Abundance)) + 
  geom_line(aes(colour = State), size = 1) +
  scale_colour_manual("State", breaks = c(2, 1),
                      values = c("blue", "grey"), 
                      labels = c("Dynamics","Observations")) +
  facet_wrap(~factor(`Age Class`, levels = c("First Year Individuals", 
                                             "Second Year Individuals", 
                                             "Third Year Individuals", 
                                             "Fourth Year Individuals")), 
             scales = "free_y") +
  ylab("Abundance") +
  ggtitle("Population Dynamics and Observations Projected over Time")
plot_BAS_ext

```

## Part a)

Given this BAS model, we first look at the potential for stochastic components modelling the sub-process abundances. For survival, we use a binomial distribution to model this sub-process abundance in the first three age classes, with parameters $n_{i,t-1}$ and $\phi_i$ for $i = 1,2,3$, respectively. The last age class abundance for this sub-process is deterministically 0, as we are told that: "Fourth year individuals always die". Next we look at the ageing sub-process. As all animals must necessarily age between time periods (years), we know this must be a deterministic process where all individuals from the previous sub-process for each age class move into to the next age class. We know the final fourth year individuals all die during the year (as per the previous sub-process) and thus do not move to a higher age class. Finally for reproduction, we choose a Poisson distribution for the first sub-process age class, whilst keeping all other age classes the same as in the previous sub process. A Poisson distribution is chosen as we know one of the reproduction rates is greater than 1 ($\rho_3 = 1.9$) so a binomial distribution is not appropriate.


The other stochastic component of this model are the observations. Given we are told the probability of detection is a static $p = 0.5$ and that no double counting can occur, a binomial distribution for the observations of each age class seems appropriate. Here for time $t$, we use the abundance for class $i$ at time $t$, $n_{i,t}$, for the number of trials and $p = 0.5$ for the probability of success.

## Part b)

In this part we functionalise the theory from a) in order to simulate the dynamics of this model. This code is visible in the appendix.

## Part c)

Finally, we run the function, projecting the animal abundance over 25 years. Storing the values for the population dynamics and observations, we then convert this into an appropriate format. This data can then be used to produce clear visualisations in the form of line plots.

```{r Q1c, eval = TRUE, fig.cap = 'Population dynamics and observations over time given a binomial distribution for the observations', echo = FALSE}

plot_BAS

```

## Extension

**This is beyond the scope of the assignment.**
Here, we look at differences when changing the observation distribution. Before, we chose a binomial distribution, we now change this to a poisson distribution for the observation of each age class, as the specification does allow for this type of distribution to be used. The rate parameter for each age class $i$ at time $t$ is $\lambda = n_{i,t} \cdot p$. Otherwise providing this function the same values as above, we produce another visualisation. 

``` {r Q1ext, eval = TRUE, fig.cap = 'Population dynamics and observations over time given a binomial distribution for the observations', echo = FALSE}

plot_BAS_ext

```

------------------------------------------------------------------------

# Question 2

------------------------------------------------------------------------

# Question 3

We will fit models to the data using values for growth rate, $r$, and carrying capacity, $K$, dependent on the recorded rainfall, $R,$ according to the data set. We will then look to test the impact of time lag when fitting models to the observed data by finding the coefficients of $r$ and $K$ with respect to $R_t$ and $R_{t-1}$.

## modelling $r$ dependent on $R_t$ and $R_{t-1}$

The previously used model has now been extended to include temporal variation in $r$:

$r = exp(\alpha_0 + \alpha_1R_t)$

$r = exp(\alpha_0 + \alpha_1R_{t-1})$

By finding the likelihood of the model according to observed values of N and using an optimisation function, parameter values of $\alpha_0$ and $\alpha_1$ can be found to calculate $r$ for each time period. Each model can then be used to project N as shown by Figure 3. The AIC and BIC of each model is displayed in Table 1 and used for model comparison.

```{r Q3a, eval = TRUE, include=FALSE}
#First a dataframe will need to be created to store the optimal alpha values as well as the model comparison AIC and BIC values
alpha_values <- data.frame(matrix(0, nrow = 2, ncol = 4))
rownames(alpha_values ) = c('r ~ Rt', 'r ~ Rt-1')
colnames(alpha_values )= c('ALPHA 0' , 'ALPHA 1', 'AIC', 'BIC')

combined_values <- data.frame(matrix(0, nrow = 3, ncol = 6))
rownames(combined_values ) = c('r ~ Rt', 'K ~ Rt', 'r & K ~ Rt')
colnames(combined_values )= c('ALPHA 0' , 'ALPHA 1','BETA 0', 'BETA 1', 'AIC', 'BIC')

rainr_t <- function(pars, years, removals, Nhat, SEhat, rain, t){
  N0 <- exp(pars[1])
  beta0 <- pars[2]   
  beta1 <- pars[3]   
  k <- exp(pars[4])
  
  N <- numeric(years)
  r <- numeric(years)
  N[1] <- N0
  r[1] <- NA           
  
  #generate population dynamics:
  for(i in 2:years){
    if (t == 't-1'){
      r[i] <- exp(beta0 + beta1*rain[(i-1)]) 
    }
    else{
      r[i] <- exp(beta0 + beta1*rain[i])  
    }
    N[i] = N[i-1] + r[i] * N[i-1] * (1-N[i-1]/k) - removals[i-1]
  }
 
  negloglik <- -sum(dnorm(Nhat,N,SEhat, log=TRUE), na.rm=TRUE)
  
  return(negloglik)   #return the negative log likelihood
}

N0 <- log(0.1)
beta0 <- log(1.5)
beta1 <-  0.2 
k <- log(1.5)
parsr <- c(N0,beta0,beta1,k)

optimised_values <- optim(parsr, 
                   fn = rainr_t,
                   years = nrow(wildebeest), 
                   removals = wildebeest$Catch,
                   Nhat = wildebeest$Nhat,
                   SEhat = wildebeest$sehat,
                   rain = wildebeest$rain,
                   t = 't')

# set up parameters using the optimised values above
N0 <- exp(optimised_values$par[1])
beta0 <- optimised_values$par[2]
beta1 <- optimised_values$par[3]
k <- exp(optimised_values$par[4])
pars <- c(N0,beta0,beta1,k)
N <- numeric(nrow(wildebeest))
r <- numeric(nrow(wildebeest))

alpha_values[1,1] = beta0
alpha_values[1,2] = beta1
combined_values[1,1] = beta0
combined_values[1,2] = beta1
combined_values[1,3] = NA
combined_values[1,4] = NA
alpha_values[1,3] <- 2 * optimised_values$value + 2*(length(optimised_values$par))
alpha_values[1,4] <- 2 * optimised_values$value + log(12) * (length(optimised_values$par))
combined_values[1,5] <- 2 * optimised_values$value + 2*(length(optimised_values$par))
combined_values[1,6] <- 2 * optimised_values$value + log(12) * (length(optimised_values$par))

#first year
N[1] <- N0
r[1] <- NA #1st K not in the model

#subsequent years
for(i in 2:nrow(wildebeest)){
  r[i] <- exp(beta0 + beta1*wildebeest$rain[i])
  N[i] = N[i-1] + r[i] * N[i-1] * (1-N[i-1]/k) - wildebeest$Catch[i-1]
}

tmp_wilde <- data.frame(Nhat = wildebeest$Nhat,
                        Nproj = N,
                        Year = wildebeest$year,
                        lci = wildebeest$lci,
                        uci = wildebeest$uci)

#plot the projections and the estimates
plot1 <- ggplot(tmp_wilde, aes(x=Year, y=Nproj)) +
  geom_errorbar(aes(ymin=lci,ymax=uci), width=0, color="grey") +
  geom_point(aes(x=Year,y=Nhat), size=3) +
  geom_line(aes(x=Year,y=Nproj),color="blue", size=1) +
  ylim(0,2.1) + ylab("Abundance (millions)") +
  labs(title = expression("Model with r dependent on R"[t])) +
  theme_bw() +
  theme(aspect.ratio = 1)

#---- rt ~ Rt-1 ----
N0 <- log(0.1)
beta0 <- log(1.5)
beta1 <-  0.2 
k <- log(1.5)
parsr <- c(N0,optimised_values$par[2],optimised_values$par[3],optimised_values$par[4])

optimised_values <- optim(parsr, 
                          fn = rainr_t,
                          years = nrow(wildebeest), 
                          removals = wildebeest$Catch,
                          Nhat = wildebeest$Nhat,
                          SEhat = wildebeest$sehat,
                          rain = wildebeest$rain,
                          t = 't-1')

# set up parameters using the optimised values above
N0 <- exp(optimised_values$par[1])
beta0 <- optimised_values$par[2]
beta1 <- optimised_values$par[3]
k <- exp(optimised_values$par[4])
N <- numeric(nrow(wildebeest))
r <- numeric(nrow(wildebeest))

alpha_values[2,1] = beta0
alpha_values[2,2] = beta1
alpha_values[2,3] <- 2 * optimised_values$value + 2*(length(optimised_values$par))
alpha_values[2,4] <- 2 * optimised_values$value + log(12) * (length(optimised_values$par))

#first year
N[1] <- N0
r[1] <- NA #1st K not in the model

#subsequent years
for(i in 2:nrow(wildebeest)){
  r[i] <- exp(beta0 + beta1*wildebeest$rain[i-1])
  N[i] = N[i-1] + r[i] * N[i-1] * (1-N[i-1]/k) - wildebeest$Catch[i-1]
}

tmp_wilde <- data.frame(Nhat = wildebeest$Nhat,
                        Nproj = N,
                        Year = wildebeest$year,
                        lci = wildebeest$lci,
                        uci = wildebeest$uci)

#plot the projections and the estimates
plot2 <-ggplot(tmp_wilde, aes(x=Year, y=Nproj)) +
  geom_errorbar(aes(ymin=lci,ymax=uci), width=0, color="grey") +
  geom_point(aes(x=Year,y=Nhat), size=3) +
  geom_line(aes(x=Year,y=Nproj),color="blue", size=1) +
  ylim(0,2.1) + ylab("Abundance (millions)") +
  labs(title = expression("Model with r dependent on R"[t-1])) +
  theme_bw() +
  theme(aspect.ratio = 1)

```

```{r 3aplots, results='hide', echo=FALSE, warning=FALSE, fig.cap='A plot of the model fits with $r$ depending on $R_t$ and $R_{t-1}$ respectively'}
grid.arrange(plot1, plot2, ncol = 2)
```

```{r alpha_table, echo=FALSE}
kable(alpha_values, caption = "Coefficients and model comparisons for time varying r")
```

The AIC and BIC value can be used to compare models to fnd the best fit for the data. By comparing AIC values, the first model $r = exp(\alpha_0 + \alpha_1R_t)$is preferable as it produces the lowest value. This is also confirmed by havin a loer BIC value that its competitor. Looking at the coefficent estimates we can see that $\alpha_0$ is equal to $-2.98$ which is negative. This will mean that the intercept of the r equation when there is no rainfall is less than 1. This intercept represents the baseline or mimimum growth rate independent of rainfall. It is also shown for this optimal model that $\alpha_1 = 0.632$. This positive value shows that rainfall has a positive impact on the growth rate. To put this into context we can conclude that this model implies that as rainfall increases, the maximum growth rate will also increase causing a greater abundance estimate.

## Modelling $K$ dependent on $R_t$ and $R_{t-1}$

Using the same optimization methods used previously for modelling the temporal variation of $r$, we can now extend the model to include temporal variation of $K$. The two formulations of K modeled are:

$K = exp(\beta_0 + \beta_1R_t)$

$K = exp(\beta_0 + \beta_1R_{t-1})$

Again through the use of optimisation, coefficient values for $\beta_0$ and $\beta_1$ were used to model projections for $N$, plotted in Figure 3, alongside the respective AIC and BIC values displayed in table 2.

```{r Q3b, eval = TRUE, include=FALSE}

beta_values <- data.frame(matrix(0, ncol = 4, nrow = 2))
rownames(beta_values ) = c('k ~ Rt', 'k ~ Rt-1')
#colnames(beta_values )= c('\u03B2_0' , '\u03B2_1', 'AIC')
colnames(beta_values )= c('BETA 0' , 'BETA 1', 'AIC', 'BIC')
#---- k ~ Rt ----
rainK_t <- function(pars, years, removals, Nhat, SEhat, rain, t){
  
  N0 <- exp(pars[1])
  r <- exp(pars[2])
  beta0 <- pars[3]   #not transformed |
  beta1 <- pars[4]   #not transformed |-> note extra parameter now
  N <- numeric(years)
  k <- numeric(years)
  N[1] <- N0
  k[1] <- NA          #1st K not in the model 
  
  for(i in 2:years){    #generate population dynamics:
    if (t == 't-1'){
      k[i] <- exp(beta0 + beta1*rain[(i-1)]) #link fn of the linear predictor 
    }
    else{
      k[i] <- exp(beta0 + beta1*rain[i]) #link fn of the linear predictor 
    }
    N[i] = N[i-1] + (r * N[i-1] * (1-N[i-1]/k[i])) - removals[i-1]
  }
  negloglik <- -sum(dnorm(Nhat,N,SEhat, log=TRUE), na.rm=TRUE)
  
  return(negloglik) 
}

N0 <- log(0.1)
r <- log(0.25)
beta0 <-  log(0.5)   
beta1 <-  log(0.5)          

parsk <- c(N0,r,beta0,beta1)
fit_rainK <- optim(parsk,
                   fn = rainK_t,
                   years = nrow(wildebeest), 
                   removals = wildebeest$Catch,
                   Nhat = wildebeest$Nhat,
                   SEhat = wildebeest$sehat,
                   rain = wildebeest$rain,
                   t = 't')

# set up parameters
N0 <- exp(fit_rainK$par[1])
r <- exp(fit_rainK$par[2])
beta0 <- fit_rainK$par[3]
beta1 <- fit_rainK$par[4]
pars <- c(N0, r, beta0,beta1)

beta_values[1,1] = beta0
beta_values[1,2] = beta1
combined_values[2,1] = NA
combined_values[2,2] = NA
combined_values[2,3] = beta0
combined_values[2,4] = beta1
N <- numeric(nrow(wildebeest))
k <- numeric(nrow(wildebeest))
beta_values[1,3] <- 2 * fit_rainK$value + 2*length(fit_rainK$par)
beta_values[1,4] <- 2 * fit_rainK$value + log(12)*length(fit_rainK$par)
combined_values[2,5] <- 2 * fit_rainK$value + 2*length(fit_rainK$par)
combined_values[2,6] <- 2 * fit_rainK$value + log(12)*length(fit_rainK$par)

#first year
N[1] <- N0
k[1] <- NA #1st K not in the model

#subsequent years
for(i in 2:nrow(wildebeest)){
  k[i] <- exp(beta0 + beta1*wildebeest$rain[i])
  N[i] = N[i-1] + r * N[i-1] * (1-N[i-1]/k[i]) - wildebeest$Catch[i-1]
}

tmp_wilde <- data.frame(Nhat = wildebeest$Nhat,
                        Nproj = N,
                        Year = wildebeest$year,
                        lci = wildebeest$lci,
                        uci = wildebeest$uci)

#plot the projections and the estimates
plot3 <- ggplot(tmp_wilde, aes(x=Year, y=Nproj)) +
  geom_errorbar(aes(ymin=lci,ymax=uci), width=0, color="grey") +
  geom_point(aes(x=Year,y=Nhat), size=3) +
  geom_line(aes(x=Year,y=Nproj),color="blue", size=1) +
  ylim(0,2.1) + ylab("Abundance (millions)") +
  labs(title = expression("Model with k dependent on R"[t])) +
  theme_bw() +
  theme(aspect.ratio = 1)

#---- Kt ~ Rt-1 ----

fit_rainK <- optim(parsk,
                   fn = rainK_t,
                   years = nrow(wildebeest), 
                   removals = wildebeest$Catch,
                   Nhat = wildebeest$Nhat,
                   SEhat = wildebeest$sehat,
                   rain = wildebeest$rain,
                   t = 't-1')

# set up parameters
N0 <- exp(fit_rainK$par[1])
r <- exp(fit_rainK$par[2])
beta0 <- fit_rainK$par[3]
beta1 <- fit_rainK$par[4]
pars <- c(N0, r, beta0,beta1)

beta_values[2,1] = beta0
beta_values[2,2] = beta1
N <- numeric(nrow(wildebeest))
k <- numeric(nrow(wildebeest))
beta_values[2,3] <- 2 * fit_rainK$value + 2*length(fit_rainK$par)
beta_values[2,4] <- 2 * fit_rainK$value + log(12)*length(fit_rainK$par)

N[1] <- N0
k[1] <- NA #1st K not in the model

#subsequent years
for(i in 2:nrow(wildebeest)){
  k[i] <- exp(beta0 + beta1*wildebeest$rain[i])
  N[i] = N[i-1] + r * N[i-1] * (1-N[i-1]/k[i]) - wildebeest$Catch[i-1]
}

tmp_wilde <- data.frame(Nhat = wildebeest$Nhat,
                        Nproj = N,
                        Year = wildebeest$year,
                        lci = wildebeest$lci,
                        uci = wildebeest$uci)

#plot the projections and the estimates
plot4 <- ggplot(tmp_wilde, aes(x=Year, y=Nproj)) +
  geom_errorbar(aes(ymin=lci,ymax=uci), width=0, color="grey") +
  geom_point(aes(x=Year,y=Nhat), size=3) +
  geom_line(aes(x=Year,y=Nproj),color="blue", size=1) +
  ylim(0,2.1) + ylab("Abundance (millions)") +
  labs(title = expression("Model with k dependent on R"[t-1])) +
  theme_bw() +
  theme(aspect.ratio = 1)

```

```{r 3bplot, results='hide', echo=FALSE, warning=FALSE, fig.cap='A plot of the model fits with K depending on $R_t$ and $R_{t-1}$ respectively'}
grid.arrange(plot3, plot4, ncol = 2)
```

```{r k AIC, echo=FALSE}
kable(beta_values, caption = "Coefficients and model comparisons for time varying K")
```

From comparing the AIC values of the competing models in Table 2, the optimal choice appears to use $K$ as a function of $R_t$. Within this model $\beta_0 = -0.497$ and $\beta_1 = 1.02$. This intercept ter $\beta_0$ implies that with no rainfall the carrying capacity is at least 608,000 individuals. The positive value of $\beta_1$ implies that rain has a positive effect on the carrying capacity and so more rain will lead to a greater carrying capacity.

Comparing the value of $\beta_1$ to the previously found $\alpha_1$ it appears that $\alpha_1 < \beta_1$. This will cause $K$ to to be more sensitive to changes in rainfall compared to $r$ when both dependent on $R_t$. Within the context of this research this can lead us to say that the carrying capacity is more heavily influenced by rainful than the growth rate.

## The Optimal Model?

By comparing the AIC and BIC scores of all 4 models, it would appear that the optimal model according to the lowest scores is that which calculates K dependent on $R_t$, followed by the model with dependence of $r$ on $R_t$.

## Modelling both temporal $r$ and $K$

From the above model comparisons it has been shown that the models perform better when using $r$ or $K$ dependent on $R_{t-1}$, but what if we calculate $r$ and $K$ as follows:

$r = exp(\alpha_0 + \alpha_1R_{t-1})$

$K = exp(\beta_0 + \beta_1R_{t-1})$

This arises to model fit displayed in Figure 4. Table 3 displays the coefficient values for the equations above for the model in addition to those found in the optimal models using only a single non constant variable to allow for comparison.

```{r Q3extra, eval = TRUE, include=FALSE}

#----r & K ~ t-1 ----

rainr_K_t <- function(pars, years, removals, Nhat, SEhat, rain){
  N0 <- exp(pars[1])
  alpha0 <- pars[2]   
  alpha1 <- pars[3] 
  beta0 <- pars[4]   
  beta1 <- pars[5] 
  
  N <- numeric(years)
  r <- numeric(years)
  k <- numeric(years)
  N[1] <- N0
  r[1] <- NA 
  k[1] <- NA
  
  #generate population dynamics:
  for(i in 2:years){
    r[i] <- exp(alpha0 + alpha1*rain[(i)]) 
    k[i] <- exp(beta0 + beta1*rain[(i)])
    N[i] = N[i-1] + r[i] * N[i-1] * (1-N[i-1]/k[i]) - removals[i-1]
  }
  
  negloglik <- -sum(dnorm(Nhat,N,SEhat, log=TRUE), na.rm=TRUE)
  
  return(negloglik)   #return the negative log likelihood
}

N0 <- log(0.1)
alpha0 <- log(0.5)
alpha1 <-  log(0.5) 
beta0 <-  log(0.5)   
beta1 <-  log(0.5)
parsr <- c(N0,alpha0, alpha1, beta0, beta1)

optimised_values <- optim(parsr, 
                          fn = rainr_K_t,
                          years = nrow(wildebeest), 
                          removals = wildebeest$Catch,
                          Nhat = wildebeest$Nhat,
                          SEhat = wildebeest$sehat,
                          rain = wildebeest$rain)

# set up parameters using the optimised values above
N0 <- exp(optimised_values$par[1])
alpha0 <- optimised_values$par[2]
alpha1 <- optimised_values$par[3]
beta0 <- optimised_values$par[4]
beta1 <- optimised_values$par[5]
pars <- c(N0,alpha0, alpha1, beta0,beta1,k)

N <- numeric(nrow(wildebeest))
r <- numeric(nrow(wildebeest))
k <- numeric(nrow(wildebeest))

combined_values[3,1] = alpha0
combined_values[3,2] = alpha1
combined_values[3,3] = beta0
combined_values[3,4] = beta1
combined_values[3,5] <- 2 * optimised_values$value + 2*(length(optimised_values$par))
combined_values[3,6] <- 2 * optimised_values$value + log(12) * (length(optimised_values$par))

#first year
N[1] <- N0
r[1] <- NA 
k[1] <- NA

#subsequent years
for(i in 2:nrow(wildebeest)){
  r[i] <- exp(alpha0 + alpha1*wildebeest$rain[(i)])
  k[i] <- exp(beta0 + beta1*wildebeest$rain[(i)])
  N[i] = N[i-1] + r[i] * N[i-1] * (1-N[i-1]/k[i]) - wildebeest$Catch[i-1]
}

tmp_wilde <- data.frame(Nhat = wildebeest$Nhat,
                        Nproj = N,
                        Year = wildebeest$year,
                        lci = wildebeest$lci,
                        uci = wildebeest$uci)

#plot the projections and the estimates
plot5 <- ggplot(tmp_wilde, aes(x=Year, y=Nproj)) +
  geom_errorbar(aes(ymin=lci,ymax=uci), width=0, color="grey") +
  geom_point(aes(x=Year,y=Nhat), size=3) +
  geom_line(aes(x=Year,y=Nproj),color="blue", size=1) +
  ylim(0,2.1) + ylab("Abundance (millions)") +
  labs(title = expression("Model with r and K dependent on R"[t])) +
  theme_bw() +
  theme(aspect.ratio = 1)

```

```{r 3extraplot, results='hide', echo=FALSE, warning=FALSE, fig.align='center', fig.cap ='Model with $r$ and $K$ dependent on $R_t$'}
grid.arrange(plot5, ncol = 1)
```

```{r r and K AIC, echo=FALSE}
kable(combined_values, caption = "Coefficient and model comparison values")
```

From Table 3 it can be seen that both the AIC and BIC for the final model are greater than the models using only a single variable dependent on Rainfall. This would suggest that there is no immediate benefit to using a more complex model utilising multiple non constant coefficients.

It can also be seen by comparison that the coefficient values for the model with both $\alpha_1$ and $\beta_1$ appear to have a smaller magnitude than those of the models with only a single time varying variable suggesting that compared to the individual models the impact of rainfall on each coeffiecient has been reduced. $\alpha_1$ has now also taken a negative value implying a negative relationship between the maximum growth rate and rainfall, contradicting the observations made previously in the model with only r displaying temporal variation.

------------------------------------------------------------------------

\newpage

# Appendix

## Question 1 Code

``` {r Q1append, eval = FALSE}

# a)

# See written report

# b)

# Write an R script to simulate dynamics from this model.
# we do this in a function.

# INPUT : 
# n0 = initial populations
# phi = survival probabilities
# rho = reproduction rates
# p = probability of detection
# nyears = number of years over which population is projected
# PROCESS : 
# calculate the stochastic population dynamics and observations for each year
# OUTPUT :
# y = array of observations for each year, across all age classes
# n = array of abundances for each year, across all age classes

BAS_stoch <- function(n0, phi, rho, p, nyears) {
  
  # initialise
  
  # matrix of all abundances, each column is a year, row is age class
  n <- matrix(data = NA, nrow = length(n0), ncol = (nyears+1))
  
  # matrix of all observations
  y <- n #replicate n
  
  # initial abundance
  # let the first set of abundances (at t = 0) be the initial population size
  n[,1] <- n0
  
  # initial observation
  # ASSUMPTION: binomial distribution as constant probability of detection (see Newman)
  y[1,1] <- rbinom(n = 1, size = n[1,1], prob = p)
  y[2,1] <- rbinom(n = 1, size = n[2,1], prob = p)
  y[3,1] <- rbinom(n = 1, size = n[3,1], prob = p)
  y[4,1] <- rbinom(n = 1, size = n[4,1], prob = p)
  
  # loop over all (other) years
  for (i in 2:(nyears+1)) {
    
    # calculate stochastic sub-processes for BAS model
    
    # Survival process
    u_1s1t <- rbinom(n = 1, size = n[1,i-1], prob = phi[1])
    u_1s2t <- rbinom(n = 1, size = n[2,i-1], prob = phi[2])
    u_1s3t <- rbinom(n = 1, size = n[3,i-1], prob = phi[3])
    u_1s4t <- 0
    
    # Ageing process
    u_2a1t <- 0
    u_2a2t <- u_1s1t
    u_2a3t <- u_1s2t
    u_2a4t <- u_1s3t + u_1s4t
    
    # Reproduction/Birth process
    u_3b1t <- rpois(n = 1, lambda = rho[1] * u_2a2t) + 
              rpois(n = 1, lambda = rho[2] * u_2a3t)
    u_3b2t <- u_2a2t
    u_3b3t <- u_2a3t
    u_3b4t <- u_2a4t
    
    # new abundances
    n[,i] <- c(u_3b1t, u_3b2t, u_3b3t, u_3b4t)
    
    # new observations
    y[1,i] <- rbinom(n = 1, size = n[1,i], prob = p)
    y[2,i] <- rbinom(n = 1, size = n[2,i], prob = p)
    y[3,i] <- rbinom(n = 1, size = n[3,i], prob = p)
    y[4,i] <- rbinom(n = 1, size = n[4,i], prob = p)
  }
  
  # return
  return(list(n=n,y=y))
  
}

# parameters from specification
phi <- c(0.45, 0.7, 0.7)
rho <- c(0.9, 1.9)
p <- 0.5
n0 <- c(150, 70, 50, 30)

# c)

# Simulate 25 years of age-specific population dynamics and observations and 
# produce an informative visualisation of the data.

# specify how many years to project over
nyears <- 25

# run function for 25 years
BAS_proj <- BAS_stoch(n0 = n0, phi = phi, rho = rho, p = p, nyears = nyears)

# visualise the data using a faceted ggplot.

# convert both outputs to dataframes
proj_n_df <- as.data.frame( cbind(0:nyears, t(BAS_proj$n), 
                    rep(2,(nyears+1))) )
proj_y_df <- as.data.frame( cbind(0:nyears, t(BAS_proj$y), 
                    rep(1,(nyears+1))) )

# rename
colnames(proj_n_df) <- c("Year", "First Year Individuals", 
                         "Second Year Individuals", 
                         "Third Year Individuals", 
                         "Fourth Year Individuals", "State")
colnames(proj_y_df) <- c("Year", "First Year Individuals", 
                         "Second Year Individuals", 
                         "Third Year Individuals", 
                         "Fourth Year Individuals", "State")

# pivot longer
proj_n_df_long <- pivot_longer(data = proj_n_df, 
                               cols = c("First Year Individuals", 
                                        "Second Year Individuals", 
                                        "Third Year Individuals", 
                                        "Fourth Year Individuals"))
proj_y_df_long <- pivot_longer(data = proj_y_df, 
                               cols = c("First Year Individuals", 
                                        "Second Year Individuals", 
                                        "Third Year Individuals", 
                                        "Fourth Year Individuals"))
proj_df_long <- rbind(proj_n_df_long, proj_y_df_long)
colnames(proj_df_long) <- c("Year", "State", "Age Class", "Abundance")

# change variable types
proj_df_long$State <- as.factor(proj_df_long$State)
proj_df_long$`Age Class` <- as.factor(proj_df_long$`Age Class`)

# Can now easily use faceted ggplot
plot_BAS <- ggplot(data = proj_df_long, aes(x = Year, y = Abundance)) + 
  geom_line(aes(colour = State), size = 1) +
  scale_colour_manual("State", breaks = c(2, 1),
                      values = c("blue", "grey"), 
                      labels = c("Dynamics","Observations")) +
  facet_wrap(~factor(`Age Class`, levels = c("First Year Individuals", 
                                             "Second Year Individuals", 
                                             "Third Year Individuals", 
                                             "Fourth Year Individuals")), 
             scales = "free_y") +
  ylab("Abundance") +
  ggtitle("Population Dynamics and Observations Projected over Time")
plot_BAS

# Extension to part b) and c)

# Create a new function like in b), but runs poisson instead of Binomial for 
# observations

# INPUT : 
# n0 = initial populations
# phi = survival probabilities
# rho = reproduction rates
# p = probability of detection
# nyears = number of years over which population is projected
# PROCESS : 
# calculate the stochastic population dynamics and observations for each year
# OUTPUT :
# y = array of observations for each year, across all age classes
# n = array of abundances for each year, across all age classes

BAS_extension <- function(n0, phi, rho, p, nyears) {
  
  # initialise
  
  # matrix of all abundances, each column is a year, row is age class
  n <- matrix(data = NA, nrow = length(n0), ncol = (nyears+1))
  
  # matrix of all observations
  y <- n #replicate n
  
  # initial abundance
  # let the first set of abundances (at t = 0) be the initial population size
  n[,1] <- n0
  
  # initial observation
  y[1,1] <- rpois(n = 1, lambda = n[1,1]*p)
  y[2,1] <- rpois(n = 1, lambda = n[2,1]*p)
  y[3,1] <- rpois(n = 1, lambda = n[3,1]*p)
  y[4,1] <- rpois(n = 1, lambda = n[4,1]*p)
  
  # loop over all (other) years
  for (i in 2:(nyears+1)) {
    
    # calculate stochastic sub-processes for BAS model
    
    # Survival process
    u_1s1t <- rbinom(n = 1, size = n[1,i-1], prob = phi[1])
    u_1s2t <- rbinom(n = 1, size = n[2,i-1], prob = phi[2])
    u_1s3t <- rbinom(n = 1, size = n[3,i-1], prob = phi[3])
    u_1s4t <- 0
    
    # Ageing process
    u_2a1t <- 0
    u_2a2t <- u_1s1t
    u_2a3t <- u_1s2t
    u_2a4t <- u_1s3t + u_1s4t
    
    # Reproduction/Birth process
    u_3b1t <- rpois(n = 1, lambda = rho[1] * u_2a2t) + 
      rpois(n = 1, lambda = rho[2] * u_2a3t)
    u_3b2t <- u_2a2t
    u_3b3t <- u_2a3t
    u_3b4t <- u_2a4t
    
    # new abundances
    n[,i] <- c(u_3b1t, u_3b2t, u_3b3t, u_3b4t)
    
    # new observations
    y[1,i] <- rpois(n = 1, lambda = n[1,i]*p)
    y[2,i] <- rpois(n = 1, lambda = n[2,i]*p)
    y[3,i] <- rpois(n = 1, lambda = n[3,i]*p)
    y[4,i] <- rpois(n = 1, lambda = n[4,i]*p)
  }
  
  # return
  return(list(n=n,y=y))
  
}

# Simulate 25 years of age-specific population dynamics and observations and 
# produce an informative visualisation of the data.

# run function for 25 years
# use same parameter values as above
BAS_proj_ext <- BAS_extension(n0 = n0, phi = phi, rho = rho, p = p, 
                              nyears = nyears)

# visualise the data using a faceted ggplot.

# convert both outputs to dataframes
proj_n_df <- as.data.frame( cbind(0:nyears, t(BAS_proj_ext$n), 
                                  rep(2,(nyears+1))) )
proj_y_df <- as.data.frame( cbind(0:nyears, t(BAS_proj_ext$y), 
                                  rep(1,(nyears+1))) )

# rename
colnames(proj_n_df) <- c("Year", "First Year Individuals", 
                         "Second Year Individuals", 
                         "Third Year Individuals", 
                         "Fourth Year Individuals", "State")
colnames(proj_y_df) <- c("Year", "First Year Individuals", 
                         "Second Year Individuals", 
                         "Third Year Individuals", 
                         "Fourth Year Individuals", "State")

# pivot longer
proj_n_df_long <- pivot_longer(data = proj_n_df, 
                               cols = c("First Year Individuals", 
                                        "Second Year Individuals", 
                                        "Third Year Individuals", 
                                        "Fourth Year Individuals"))
proj_y_df_long <- pivot_longer(data = proj_y_df, 
                               cols = c("First Year Individuals", 
                                        "Second Year Individuals", 
                                        "Third Year Individuals", 
                                        "Fourth Year Individuals"))
proj_df_long <- rbind(proj_n_df_long, proj_y_df_long)
colnames(proj_df_long) <- c("Year", "State", "Age Class", "Abundance")

# change variable types
proj_df_long$State <- as.factor(proj_df_long$State)
proj_df_long$`Age Class` <- as.factor(proj_df_long$`Age Class`)

# Can now easily use faceted ggplot
plot_BAS_ext <- ggplot(data = proj_df_long, aes(x = Year, y = Abundance)) + 
  geom_line(aes(colour = State), size = 1) +
  scale_colour_manual("State", breaks = c(2, 1),
                      values = c("blue", "grey"), 
                      labels = c("Dynamics","Observations")) +
  facet_wrap(~factor(`Age Class`, levels = c("First Year Individuals", 
                                             "Second Year Individuals", 
                                             "Third Year Individuals", 
                                             "Fourth Year Individuals")), 
             scales = "free_y") +
  ylab("Abundance") +
  ggtitle("Population Dynamics and Observations Projected over Time")
plot_BAS_ext

```

## Question 3 Code

```{r Q3a CODE, eval = FALSE, include=TRUE}
#QUESTION 3A

#Create a datafrae to store the optimal alpha values as well as AIC and BIC values
alpha_values <- data.frame(matrix(0, nrow = 2, ncol = 4))
rownames(alpha_values ) = c('r ~ Rt', 'r ~ Rt-1')               #each row represents a model
colnames(alpha_values )= c('ALPHA 0' , 'ALPHA 1', 'AIC', 'BIC') #each column represents a value

#combined_values will store data from the optimal model in a) and b) to provide a final 
#comparison
combined_values <- data.frame(matrix(0, nrow = 3, ncol = 6))
rownames(combined_values ) = c('r ~ Rt', 'K ~ Rt', 'r & K ~ Rt')
colnames(combined_values )= c('ALPHA 0' , 'ALPHA 1','BETA 0', 'BETA 1', 'AIC', 'BIC')

#rainr_t will find the negative log-likelihood for the model constructed with the input 
#parameters. Here r varies with time.
rainr_t <- function(pars, years, removals, Nhat, SEhat, rain, t){
  #set the initial parameters
  N0 <- exp(pars[1])
  alpha0 <- pars[2]   
  alpha1 <- pars[3]   
  k <- exp(pars[4])
  
  #create a list the length of the number of years we ish to project to store the projections
  N <- numeric(years)
  r <- numeric(years)
  N[1] <- N0
  r[1] <- NA           
  
  #generate population dynamics
  for(i in 2:years){
    #using the input parameter t the function can specify the time lag we wish to consider when
    #finding r with respect to R
    if (t == 't-1'){
      r[i] <- exp(alpha0 + alpha1*rain[(i-1)]) 
    }
    else{
      r[i] <- exp(alpha0 + alpha1*rain[i])  
    }
    N[i] = N[i-1] + r[i] * N[i-1] * (1-N[i-1]/k) - removals[i-1]
  }
  
 #findthe negative log likelihood
  negloglik <- -sum(dnorm(Nhat,N,SEhat, log=TRUE), na.rm=TRUE)
  
  return(negloglik)   #return the negative log likelihood
}

#to run the function we must now set some initil values for the unknown parameters we wish to 
#test
N0 <- log(0.1)
alpha0 <- log(1.5)
alpha1 <-  0.2 
k <- log(1.5)
parsr <- c(N0,alpha0,alpha1,k)          #store these values in a list

#run the optimiser function to find the optimal coefficient values
optimised_values <- optim(parsr, 
                   fn = rainr_t,
                   years = nrow(wildebeest), 
                   removals = wildebeest$Catch,
                   Nhat = wildebeest$Nhat,
                   SEhat = wildebeest$sehat,
                   rain = wildebeest$rain,
                   t = 't')

# set up parameters using the optimised values above
N0 <- exp(optimised_values$par[1])
alpha0 <- optimised_values$par[2]
alpha1 <- optimised_values$par[3]
k <- exp(optimised_values$par[4])
pars <- c(N0, alpha0, alpha1,k)
N <- numeric(nrow(wildebeest))
r <- numeric(nrow(wildebeest))

#store these values in the previously mentioned dataframes for later comparison to other models
alpha_values[1,1] = alpha0
alpha_values[1,2] = alpha1
alpha_values[1,3] <- 2 * optimised_values$value + 2*(length(optimised_values$par))
alpha_values[1,4] <- 2 * optimised_values$value + log(12) * (length(optimised_values$par))

combined_values[1,1] = alpha0
combined_values[1,2] = alpha1
combined_values[1,3] = NA
combined_values[1,4] = NA
combined_values[1,5] <- 2 * optimised_values$value + 2*(length(optimised_values$par))
combined_values[1,6] <- 2 * optimised_values$value + log(12) * (length(optimised_values$par))

#first year
N[1] <- N0
r[1] <- NA #1st K not in the model

#subsequent years
for(i in 2:nrow(wildebeest)){
  r[i] <- exp(alpha0 + alpha1*wildebeest$rain[i])
  N[i] = N[i-1] + r[i] * N[i-1] * (1-N[i-1]/k) - wildebeest$Catch[i-1]
}

tmp_wilde <- data.frame(Nhat = wildebeest$Nhat,
                        Nproj = N,
                        Year = wildebeest$year,
                        lci = wildebeest$lci,
                        uci = wildebeest$uci)

#plot the projections and the estimates
plot1 <- ggplot(tmp_wilde, aes(x=Year, y=Nproj)) +
  geom_errorbar(aes(ymin=lci,ymax=uci), width=0, color="grey") +
  geom_point(aes(x=Year,y=Nhat), size=3) +
  geom_line(aes(x=Year,y=Nproj),color="blue", size=1) +
  ylim(0,2.1) + ylab("Abundance (millions)") +
  labs(title = expression("Model with r dependent on R"[t])) +
  theme_bw() +
  theme(aspect.ratio = 1)

#---- rt ~ Rt-1 ----
#reset the intial parameter estimates. These values have been used as other combination caused 
#false results due to the optimisation finding local minima for the negative log likelihood
parsr <- c(N0,optimised_values$par[2],optimised_values$par[3],optimised_values$par[4])

#rerun the optimiser
optimised_values <- optim(parsr, 
                          fn = rainr_t,
                          years = nrow(wildebeest), 
                          removals = wildebeest$Catch,
                          Nhat = wildebeest$Nhat,
                          SEhat = wildebeest$sehat,
                          rain = wildebeest$rain,
                          t = 't-1')

# set up parameters using the optimised values above
N0 <- exp(optimised_values$par[1])
beta0 <- optimised_values$par[2]
beta1 <- optimised_values$par[3]
k <- exp(optimised_values$par[4])
N <- numeric(nrow(wildebeest))
r <- numeric(nrow(wildebeest))

#store optimal values for later comparison beteen models
alpha_values[2,1] = beta0
alpha_values[2,2] = beta1
alpha_values[2,3] <- 2 * optimised_values$value + 2*(length(optimised_values$par))
alpha_values[2,4] <- 2 * optimised_values$value + log(12) * (length(optimised_values$par))

#first year
N[1] <- N0
r[1] <- NA #1st K not in the model

#subsequent years
for(i in 2:nrow(wildebeest)){
  r[i] <- exp(beta0 + beta1*wildebeest$rain[i-1])
  N[i] = N[i-1] + r[i] * N[i-1] * (1-N[i-1]/k) - wildebeest$Catch[i-1]
}

tmp_wilde <- data.frame(Nhat = wildebeest$Nhat,
                        Nproj = N,
                        Year = wildebeest$year,
                        lci = wildebeest$lci,
                        uci = wildebeest$uci)

#create a plot of the projections and the estimates
plot2 <-ggplot(tmp_wilde, aes(x=Year, y=Nproj)) +
  geom_errorbar(aes(ymin=lci,ymax=uci), width=0, color="grey") +
  geom_point(aes(x=Year,y=Nhat), size=3) +
  geom_line(aes(x=Year,y=Nproj),color="blue", size=1) +
  ylim(0,2.1) + ylab("Abundance (millions)") +
  labs(title = expression("Model with r dependent on R"[t-1])) +
  theme_bw() +
  theme(aspect.ratio = 1)

#plot the projections of the models using different time lags side by side for comparison
grid.arrange(plot1, plot2, ncol = 2)
#output the table of coefficient values and comparison metrics
kable(alpha_values, caption = "Coefficients and model comparisons for time varying r")
```

```{r Q3b CODE, eval = FALSE, include=TRUE}


# QUESTION 3B


#create a new dataframe to store coefficient values, AIC and BIC
beta_values <- data.frame(matrix(0, ncol = 4, nrow = 2))
rownames(beta_values ) = c('k ~ Rt', 'k ~ Rt-1')
colnames(beta_values )= c('BETA 0' , 'BETA 1', 'AIC', 'BIC')

#---- k ~ Rt ----
#create a new function to find the negative log likelihood of models based on in put parameter 
#values. This function is the same as the one from 3a) however this time K is dependent on Rt 
#instead of r.
rainK_t <- function(pars, years, removals, Nhat, SEhat, rain, t){
  
  N0 <- exp(pars[1])
  r <- exp(pars[2])
  beta0 <- pars[3]   #not transformed |
  beta1 <- pars[4]   #not transformed |-> note extra parameter now
  N <- numeric(years)
  k <- numeric(years)
  N[1] <- N0
  k[1] <- NA          #1st K not in the model 
  
  for(i in 2:years){    #generate population dynamics:
    if (t == 't-1'){
      k[i] <- exp(beta0 + beta1*rain[(i-1)]) #link fn of the linear predictor 
    }
    else{
      k[i] <- exp(beta0 + beta1*rain[i]) #link fn of the linear predictor 
    }
    N[i] = N[i-1] + (r * N[i-1] * (1-N[i-1]/k[i])) - removals[i-1]
  }
  negloglik <- -sum(dnorm(Nhat,N,SEhat, log=TRUE), na.rm=TRUE)
  
  return(negloglik) 
}

#input starting estimates for the parameters
N0 <- log(0.1)
r <- log(0.25)
beta0 <-  log(0.5)   
beta1 <-  log(0.5)          
parsk <- c(N0,r,beta0,beta1)

#optimise the parameter estimates according to the observations
fit_rainK <- optim(parsk,
                   fn = rainK_t,
                   years = nrow(wildebeest), 
                   removals = wildebeest$Catch,
                   Nhat = wildebeest$Nhat,
                   SEhat = wildebeest$sehat,
                   rain = wildebeest$rain,
                   t = 't')

# set up optimised parameters
N0 <- exp(fit_rainK$par[1])
r <- exp(fit_rainK$par[2])
beta0 <- fit_rainK$par[3]
beta1 <- fit_rainK$par[4]
pars <- c(N0, r, beta0,beta1)

#store the values for later comparison in the previously created dataframes
beta_values[1,1] = beta0
beta_values[1,2] = beta1
beta_values[1,3] <- 2 * fit_rainK$value + 2*length(fit_rainK$par)
beta_values[1,4] <- 2 * fit_rainK$value + log(12)*length(fit_rainK$par)

combined_values[2,1] = NA       #note that the model has no alpha values
combined_values[2,2] = NA
combined_values[2,3] = beta0
combined_values[2,4] = beta1
combined_values[2,5] <- 2 * fit_rainK$value + 2*length(fit_rainK$par)
combined_values[2,6] <- 2 * fit_rainK$value + log(12)*length(fit_rainK$par)

#create vectors to store the projections
N <- numeric(nrow(wildebeest))
k <- numeric(nrow(wildebeest))
#first year
N[1] <- N0
k[1] <- NA #1st K not in the model

#subsequent years
for(i in 2:nrow(wildebeest)){
  k[i] <- exp(beta0 + beta1*wildebeest$rain[i])
  N[i] = N[i-1] + r * N[i-1] * (1-N[i-1]/k[i]) - wildebeest$Catch[i-1]
}

tmp_wilde <- data.frame(Nhat = wildebeest$Nhat,
                        Nproj = N,
                        Year = wildebeest$year,
                        lci = wildebeest$lci,
                        uci = wildebeest$uci)

#create a plot of the projections and the estimates
plot3 <- ggplot(tmp_wilde, aes(x=Year, y=Nproj)) +
  geom_errorbar(aes(ymin=lci,ymax=uci), width=0, color="grey") +
  geom_point(aes(x=Year,y=Nhat), size=3) +
  geom_line(aes(x=Year,y=Nproj),color="blue", size=1) +
  ylim(0,2.1) + ylab("Abundance (millions)") +
  labs(title = expression("Model with k dependent on R"[t])) +
  theme_bw() +
  theme(aspect.ratio = 1)

#---- Kt ~ Rt-1 ----

# with the same initial conditions as above rerun the optimiser this time specifyingthe time 
#lag as t-1 to find new optimal coefficient estimates for the model

fit_rainK <- optim(parsk,
                   fn = rainK_t,
                   years = nrow(wildebeest), 
                   removals = wildebeest$Catch,
                   Nhat = wildebeest$Nhat,
                   SEhat = wildebeest$sehat,
                   rain = wildebeest$rain,
                   t = 't-1')

# set up optimised parameters
N0 <- exp(fit_rainK$par[1])
r <- exp(fit_rainK$par[2])
beta0 <- fit_rainK$par[3]
beta1 <- fit_rainK$par[4]
pars <- c(N0, r, beta0,beta1)

#store the values of beta and calculate AIC and BIC
beta_values[2,1] = beta0
beta_values[2,2] = beta1
beta_values[2,3] <- 2 * fit_rainK$value + 2*length(fit_rainK$par)
beta_values[2,4] <- 2 * fit_rainK$value + log(12)*length(fit_rainK$par)

N <- numeric(nrow(wildebeest))
k <- numeric(nrow(wildebeest))
N[1] <- N0
k[1] <- NA #1st K not in the model

#subsequent years
for(i in 2:nrow(wildebeest)){
  k[i] <- exp(beta0 + beta1*wildebeest$rain[i])
  N[i] = N[i-1] + r * N[i-1] * (1-N[i-1]/k[i]) - wildebeest$Catch[i-1]
}

tmp_wilde <- data.frame(Nhat = wildebeest$Nhat,
                        Nproj = N,
                        Year = wildebeest$year,
                        lci = wildebeest$lci,
                        uci = wildebeest$uci)

#plot the projections and the estimates
plot4 <- ggplot(tmp_wilde, aes(x=Year, y=Nproj)) +
  geom_errorbar(aes(ymin=lci,ymax=uci), width=0, color="grey") +
  geom_point(aes(x=Year,y=Nhat), size=3) +
  geom_line(aes(x=Year,y=Nproj),color="blue", size=1) +
  ylim(0,2.1) + ylab("Abundance (millions)") +
  labs(title = expression("Model with k dependent on R"[t-1])) +
  theme_bw() +
  theme(aspect.ratio = 1)

#create a side by side plot of the different models projections of N 
grid.arrange(plot3, plot4, ncol = 2)
#output the table to compare the coefficient values and AIC / BIC values
kable(beta_values, caption = "Coefficients and model comparisons for time varying K")
```

```{r Q3extra CODE, eval = FALSE, include=TRUE}


# QUESTION 3 EXTRA


#----Modelling r & K ~ t-1 ----
#create a function to find the negative log likelihood for a model with both r and K dependent 
#on Rt. This is an extension of the functions within 3a and 3b by simply calculating r and K
rainr_K_t <- function(pars, years, removals, Nhat, SEhat, rain){
  N0 <- exp(pars[1])
  alpha0 <- pars[2]   
  alpha1 <- pars[3] 
  beta0 <- pars[4]   
  beta1 <- pars[5] 
  
  N <- numeric(years)
  r <- numeric(years)
  k <- numeric(years)
  N[1] <- N0
  r[1] <- NA 
  k[1] <- NA
  
  #generate population dynamics:
  for(i in 2:years){
    r[i] <- exp(alpha0 + alpha1*rain[(i)]) 
    k[i] <- exp(beta0 + beta1*rain[(i)])
    N[i] = N[i-1] + r[i] * N[i-1] * (1-N[i-1]/k[i]) - removals[i-1]
  }
  
  negloglik <- -sum(dnorm(Nhat,N,SEhat, log=TRUE), na.rm=TRUE)
  
  return(negloglik)   #return the negative log likelihood
}

#set initial parameter values
N0 <- log(0.1)
alpha0 <- log(0.5)
alpha1 <-  log(0.5) 
beta0 <-  log(0.5)   
beta1 <-  log(0.5)
parsr <- c(N0,alpha0, alpha1, beta0, beta1)

#optimise parameter values for the model according to the observations
optimised_values <- optim(parsr, 
                          fn = rainr_K_t,
                          years = nrow(wildebeest), 
                          removals = wildebeest$Catch,
                          Nhat = wildebeest$Nhat,
                          SEhat = wildebeest$sehat,
                          rain = wildebeest$rain)

# set up parameters using the optimised values above
N0 <- exp(optimised_values$par[1])
alpha0 <- optimised_values$par[2]
alpha1 <- optimised_values$par[3]
beta0 <- optimised_values$par[4]
beta1 <- optimised_values$par[5]
pars <- c(N0,alpha0, alpha1, beta0,beta1,k)

#store the model coefficient estimates as well as the AIC and BIC
combined_values[3,1] = alpha0
combined_values[3,2] = alpha1
combined_values[3,3] = beta0
combined_values[3,4] = beta1
combined_values[3,5] <- 2 * optimised_values$value + 2*(length(optimised_values$par))
combined_values[3,6] <- 2 * optimised_values$value + log(12) * (length(optimised_values$par))

N <- numeric(nrow(wildebeest))
r <- numeric(nrow(wildebeest))
k <- numeric(nrow(wildebeest))
#first year
N[1] <- N0
r[1] <- NA 
k[1] <- NA

#Calculate the projections for the subsequent years using the temproal r and K values
for(i in 2:nrow(wildebeest)){
  r[i] <- exp(alpha0 + alpha1*wildebeest$rain[(i)])
  k[i] <- exp(beta0 + beta1*wildebeest$rain[(i)])
  N[i] = N[i-1] + r[i] * N[i-1] * (1-N[i-1]/k[i]) - wildebeest$Catch[i-1]
}

tmp_wilde <- data.frame(Nhat = wildebeest$Nhat,
                        Nproj = N,
                        Year = wildebeest$year,
                        lci = wildebeest$lci,
                        uci = wildebeest$uci)

#create a plot of the projections of N
plot5 <- ggplot(tmp_wilde, aes(x=Year, y=Nproj)) +
  geom_errorbar(aes(ymin=lci,ymax=uci), width=0, color="grey") +
  geom_point(aes(x=Year,y=Nhat), size=3) +
  geom_line(aes(x=Year,y=Nproj),color="blue", size=1) +
  ylim(0,2.1) + ylab("Abundance (millions)") +
  labs(title = expression("Model with r and K dependent on R"[t])) +
  theme_bw() +
  theme(aspect.ratio = 1)

grid.arrange(plot5, ncol = 1)
#output the datagrame as a table for analysis
kable(combined_values, caption = "Coefficient and model comparison values")
```
